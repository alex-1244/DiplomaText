% !TeX spellcheck = russian-aot-ieyo
% Зачем: Определяет класс документа (То, как будет выглядеть документ)
% Примечание: параметр draft помечает строки, вышедшие за границы страницы, прямоугольником, в фильной версии его нужно удалить.
\documentclass[a4paper,14pt,russian,ukrainian,oneside,final]{extreport}

% Зачем: Установка кодировки исходных файлов.
\usepackage[utf8]{inputenc}

% Зачем: Делает результирующий PDF "searchable and copyable".
\usepackage{cmap}

% Зачем: Выбор внутренней TeX кодировки.
\usepackage[T2A]{fontenc}

% Зачем: Чтобы можно было использовать русские буквы в формулах, но в случае использования предупреждать об этом.
\usepackage[warn]{mathtext}

% Зачем: Учет особенностей различных языков.
\usepackage[russian]{babel}

% Зачем: Улучшает отображение русских шрифтов.
% Примечание: Требует шаманства при установке, инструкция http://plumbum-blog.blogspot.com/2010/06/miktex-28-pscyr-04d.html
%\usepackage{pscyr}


% Зачем: Добавляет поддержу дополнительных размеров текста 8pt, 9pt, 10pt, 11pt, 12pt, 14pt, 17pt, and 20pt.
% Почему: Пункт 2.1.1 Требований по оформлению пояснительной записки.
%\usepackage{extsizes}


% Зачем: Длинна, пимерно соответвующая 5 символам
% Почему: Требования содержат странное требование про отсупы в 5 символов (для немоноширинного шрифта :| )
\newlength{\fivecharsapprox}
\setlength{\fivecharsapprox}{6ex}
\newlength{\fivecharsapproxs}
\setlength{\fivecharsapproxs}{1ex}

% Зачем: Добавляет отступы для абзацев.
% Почему: Пункт 2.1.3 Требований по оформлению пояснительной записки.
\usepackage{indentfirst}
\setlength{\parindent}{\fivecharsapprox} % Примерно соответсвует 5 символам.


% Зачем: Настраивает отступы от границ страницы.
% Почему: Пункт 2.1.2 Требований по оформлению пояснительной записки.
\usepackage[left=3cm,top=2.0cm,right=1.5cm,bottom=2.7cm]{geometry}


% Зачем: Настраивает межстрочный интервал, для размещения 40 +/- 3 строки текста на странице.
% Почему: Пункт 2.1.1 Требований по оформлению пояснительной записки.
\usepackage[nodisplayskipstretch]{setspace} 
\setstretch{1.1}
%\onehalfspacing

% Зачем: Выбор шрифта по-умолчанию. 
% Почему: Пункт 2.1.1 Требований по оформлению пояснительной записки.
% Примечание: В требованиях не указан, какой именно шрифт использовать. По традиции используем TNR.
\renewcommand{\rmdefault}{ftm} % Times New Roman


% Зачем: Отключает использование изменяемых межсловных пробелов.
% Почему: Так не принято делать в текстах на русском языке.
\frenchspacing


% Зачем: Сброс счетчика сносок для каждой страницы
% Примечание: в "Требованиях по оформлению пояснительной записки" не указано, как нужно делать, но в других БГУИРовских докуметах рекомендуется нумерация отдельная для каждой страницы
\usepackage{perpage}
\MakePerPage{footnote}


% Зачем: Добавляет скобку 1) к номеру сноски
% Почему: Пункты 2.9.2 и 2.9.1 Требований по оформлению пояснительной записки.
\makeatletter 
\def\@makefnmark{\hbox{\@textsuperscript{\normalfont\@thefnmark)}}}
\makeatother


% Зачем: Расположение сносок внизу страницы
% Почему: Пункт 2.9.2 Требований по оформлению пояснительной записки.
\usepackage[bottom]{footmisc}


% Зачем: Переопределяем стандартную нумерацию, т.к. в отчете будут только section и т.д. в терминологии TeX
\makeatletter
\renewcommand{\thesection}{ \arabic{section}}




\makeatother


% Зачем: Пункты (в терминологии требований) в терминологии TeX subsubsection должны нумероваться
% Почему: Пункт 2.2.3 Требований по оформлению пояснительной записки.
\setcounter{secnumdepth}{3}


% Зачем: Настраивает отступ между таблицей с содержанимем и словом СОДЕРЖАНИЕ
% Почему: Пункт 2.2.7 Требований по оформлению пояснительной записки.
\usepackage{tocloft}
\setlength{\cftbeforetoctitleskip}{-1em}
\setlength{\cftaftertoctitleskip}{1em}





\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\thepage}
\fancyheadoffset{0mm}
\fancyfootoffset{0mm}
\setlength{\headheight}{17pt}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\fancypagestyle{plain}{ 
    \fancyhf{}
    \rhead{\thepage}}

% Зачем: Определяет отступы слева для записей в таблице содержания.
% Почему: Пункт 2.2.7 Требований по оформлению пояснительной записки.
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{0.5em}{1.2em}}
\renewcommand{\l@subsection}{\@dottedtocline{2}{1.7em}{2.0em}}
\makeatother

% Зачем: Задает стиль заголовков раздела жирным шрифтом, прописными буквами, без точки в конце
% Почему: Пункты 2.1.1, 2.2.5, 2.2.6 и ПРИЛОЖЕНИЕ Л Требований по оформлению пояснительной записки.
\makeatletter
\renewcommand\section{%
  \clearpage\@startsection {section}{0}%
    {\fivecharsapproxs}%
    {-1em \@plus -1ex \@minus -.2ex}%
    {1em \@plus .2ex}%
    {\raggedright\hyphenpenalty=10000\normalfont\large\bfseries\MakeUppercase {}}
}
\makeatother


% Зачем: Задает стиль заголовков подразделов
% Почему: Пункты 2.1.1, 2.2.5 и ПРИЛОЖЕНИЕ Л Требований по оформлению пояснительной записки.
\makeatletter
\renewcommand\subsection{%
  \@startsection{subsection}{2}%
    {\fivecharsapprox}%
    {-1em \@plus -1ex \@minus -.2ex}%
    {1em \@plus .2ex}%
    {\raggedright\hyphenpenalty=10000\normalfont\normalsize\bfseries}}
\makeatother


% Зачем: Задает стиль заголовков пунктов
% Почему: Пункты 2.1.1, 2.2.5 и ПРИЛОЖЕНИЕ Л Требований по оформлению пояснительной записки.
\makeatletter
\renewcommand\subsubsection{
  \@startsection{subsubsection}{3}%
    {\fivecharsapprox}%
    {-1em \@plus -1ex \@minus -.2ex}%
    {\z@}%
    {\raggedright\hyphenpenalty=10000\normalfont\normalsize\bfseries}}
\makeatother

% Зачем: для оформления введения и заключения, они должны быть выровнены по центру.
% Почему: Пункты 1.1.15 и 1.1.11 Требований по оформлению пояснительной записки.
\makeatletter
\newcommand\sectioncentered{%
  \clearpage\@startsection {section}{1}%
    {\z@}%
    {-1em \@plus -1ex \@minus -.2ex}%
    {1em \@plus .2ex}%
    {\centering\hyphenpenalty=10000\normalfont\large\bfseries\MakeUppercase}%
    }
\makeatother



% Зачем: Задает стиль библиографии
% Почему: Пункт 2.8.6 Требований по оформлению пояснительной записки.
\bibliographystyle{styles/belarus-specific-utf8gost780u}


% Зачем: Пакет для вставки картинок
% Примечание: Объяснение, зачем final - http://tex.stackexchange.com/questions/11004/why-does-the-image-not-appear
\usepackage[final]{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg,.eps}


% Зачем: Директория в которой будет происходить поиск картинок
\graphicspath{{figures/}}


% Зачем: Добавление подписей к рисункам
\usepackage[nooneline]{caption}
\usepackage{subcaption}

% Зачем: Задание подписей, разделителя и нумерации частей рисунков
% Почему: Пункт 2.5.5 Требований по оформлению пояснительной записки.
\DeclareCaptionLabelFormat{stbfigure}{Рис. #2}
\DeclareCaptionLabelFormat{stbtable}{Таблица #2}
\DeclareCaptionLabelSeparator{stb}{~~}
\captionsetup{labelsep=stb}
\captionsetup[figure]{labelformat=stbfigure,justification=centering}
\captionsetup[table]{labelformat=stbtable,justification=raggedright}
\renewcommand{\thesubfigure}{\asbuk{subfigure}}

% Зачем: Окружения для оформления формул
% Почему: Пункт 2.4.7 требований по оформлению пояснительной записки и специфические требования различных кафедр
\usepackage{tabularx}

\newenvironment{explanation}
    {
    %%% Следующие строки определяют специфические требования кафедр. Раскоменнтируйте нужные 2 строки
    %% стандартный абзац, Кафедра информатики
    \par 
    \tabularx{\textwidth-\fivecharsapprox}{@{}ll@{ --- } X }
    %% без отступа, Кафедра экономической информатики
    %\noindent 
    %\tabularx{\textwidth}{@{}ll@{ --- } X }
    }
    { 
    \\[\parsep]
    \endtabularx
    }


% Зачем: Удобная вёрстка многострочных формул, масштабирующийся текст в формулах, формулы в рамках и др
\usepackage{amsmath}


% Зачем: Поддержка ажурного и готического шрифтов 
\usepackage{amsfonts}


% Зачем: amsfonts + несколько сотен дополнительных математических символов
\usepackage{amssymb}


% Зачем: Окружения «теорема», «лемма»
\usepackage{amsthm}


% Зачем: Производить арифметические операции во время компиляции TeX файла
\usepackage{calc}

% Зачем: Производить арифметические операции во время компиляции TeX файла
\usepackage{fp}

% Зачем: Пакет для работы с перечислениями
\usepackage{enumitem}
\makeatletter
 \AddEnumerateCounter{\asbuk}{\@asbuk}{щ)}
\makeatother


% Зачем: Устанавливает символ начала простого перечисления
% Почему: Пункт 2.3.5 Требований по оформлению пояснительной записки.
\setlist{nolistsep}


% Зачем: Устанавливает символ начала именованного перечисления
% Почему: Пункт 2.3.8 Требований по оформлению пояснительной записки.
\renewcommand{\labelenumi}{\asbuk{enumi})}
\renewcommand{\labelenumii}{\arabic{enumii})}

% Зачем: Устанавливает отступ от границы документа до символа списка, чтобы этот отступ равнялся отступу параграфа
% Почему: Пункт 2.3.5 Требований по оформлению пояснительной записки.

\setlist[itemize,0]{itemindent=\parindent + 2.2ex,leftmargin=0ex,label=--}
\setlist[enumerate,1]{itemindent=\parindent + 2.7ex,leftmargin=0ex}
\setlist[enumerate,2]{itemindent=\parindent + \parindent - 2.7ex}

% Зачем: Включение номера раздела в номер формулы. Нумерация формул внутри раздела.
\AtBeginDocument{\numberwithin{equation}{section}}

% Зачем: Включение номера раздела в номер таблицы. Нумерация таблиц внутри раздела.
\AtBeginDocument{\numberwithin{table}{section}}

% Зачем: Включение номера раздела в номер рисунка. Нумерация рисунков внутри раздела.
\AtBeginDocument{\numberwithin{figure}{section}}


% Зачем: Дополнительные возможности в форматировании таблиц
\usepackage{makecell}
\usepackage{multirow}
\usepackage{array}


% Зачем: "Умная" запятая в математических формулах. В дробных числах не добавляет пробел
% Почему: В требованиях не нашел, но в русском языке для дробных чисел используется {,} а не {.}
\usepackage{icomma}

% Зачем: макрос для печати римских чисел
\makeatletter
\newcommand{\rmnum}[1]{\romannumeral #1}
\newcommand{\Rmnum}[1]{\expandafter\@slowromancap\romannumeral #1@}
\makeatother


% Зачем: Управление выводом чисел.
\usepackage{sistyle}
\SIdecimalsign{,}

% Зачем: inline-коментирование содержимого.
\newcommand{\ignore}[2]{\hspace{0in}#2}


% Зачем: Возможность коментировать большие участки документа
\usepackage{verbatim}


\usepackage{xcolor}


% Зачем: Оформление листингов кода
% Примечание: final нужен для переопределения режима draft, в котором листинги не выводятся в документ.
\usepackage[final]{listings}


% Зачем: настройка оформления листинга для языка F#
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{turqusnumbers}{rgb}{0.17,0.57,0.69}
\definecolor{redstrings}{rgb}{0.5,0,0}

\renewcommand{\lstlistingname}{Листинг}

\lstdefinelanguage{FSharp}
    {morekeywords={abstract,and,as,assert,base,begin,class,default,delegate,do,done,downcast,downto,elif,else,end,exception,extern,false,finally,for,fun,function,global,if,in,inherit,inline,interface,internal,lazy,let,let!,match,member,module,mutable,namespace,new,not,null,of,open,or,override,private,public,rec,return,return!,select,static,struct,then,to,true,try,type,upcast,use,use!,val,void,when,while,with,yield,yield!,asr,land,lor,lsl,lsr,lxor,mod,sig,atomic,break,checked,component,const,constraint,constructor,continue,eager,event,external,fixed,functor,include,method,mixin,object,parallel,process,protected,pure,sealed,tailcall,trait,virtual,volatile},
    keywordstyle=\bfseries\color{bluekeywords},
    sensitive=false,
    morecomment=[l][\color{greencomments}]{///},
    morecomment=[l][\color{greencomments}]{//},
    morecomment=[s][\color{greencomments}]{{(*}{*)}},
    morestring=[b]",
    stringstyle=\color{redstrings},
    }

\lstdefinestyle{fsharpstyle}{
   xleftmargin=0ex,
   language=FSharp,
   basicstyle=\footnotesize\ttfamily,
   breaklines=true,
   columns=fullflexible
}

\lstdefinestyle{csharpinlinestyle} {
  language=[Sharp]C,
  morekeywords={yield,var,get,set,from,select,partial,where,async,await},
  breaklines=true,
  columns=fullflexible,
  basicstyle=\footnotesize\ttfamily
}

\lstdefinestyle{csharpstyle}{
  language=[Sharp]C,
  frame=lr,
  rulecolor=\color{blue!80!black}}


% Зачем: Нумерация листингов в пределах секции
\AtBeginDocument{\numberwithin{lstlisting}{section}}

\usepackage[normalem]{ulem}

\usepackage[final,hidelinks]{hyperref}
% Моноширинный шрифт выглядит визуально больше, чем пропорциональный шрифт, если их размеры одинаковы. Искусственно уменьшаем размер ссылок.
\renewcommand{\UrlFont}{\small\rmfamily\tt}

\usepackage[square,numbers,sort&compress]{natbib}
\setlength{\bibsep}{0em}

% Магия для подсчета разнообразных объектов в документе
\usepackage{lastpage}
\usepackage{totcount}
\regtotcounter{section}

\usepackage{etoolbox}

\newcounter{totfigures}
\newcounter{tottables}
\newcounter{totreferences}
\newcounter{totequation}

\providecommand\totfig{} 
\providecommand\tottab{}
\providecommand\totref{}
\providecommand\toteq{}

\makeatletter
\AtEndDocument{%
  \addtocounter{totfigures}{\value{figure}}%
  \addtocounter{tottables}{\value{table}}%
  \addtocounter{totequation}{\value{equation}}
  \immediate\write\@mainaux{%
    \string\gdef\string\totfig{\number\value{totfigures}}%
    \string\gdef\string\tottab{\number\value{tottables}}%
    \string\gdef\string\totref{\number\value{totreferences}}%
    \string\gdef\string\toteq{\number\value{totequation}}%
  }%
}
\makeatother

\pretocmd{\section}{\addtocounter{totfigures}{\value{figure}}\setcounter{figure}{0}}{}{}
\pretocmd{\section}{\addtocounter{tottables}{\value{table}}\setcounter{table}{0}}{}{}
\pretocmd{\section}{\addtocounter{totequation}{\value{equation}}\setcounter{equation}{0}}{}{}
\pretocmd{\bibitem}{\addtocounter{totreferences}{1}}{}{}



% Для оформления таблиц не влязящих на 1 страницу
\usepackage{longtable}

% Для включения pdf документов в результирующий файл
\usepackage{pdfpages}

% Зачем: Переносы в словах с тире.
% Тире в словае заменяем на \hyph: аппаратно\hyphпрограммный.
% https://stackoverflow.com/questions/2193307/how-to-get-latex-to-hyphenate-a-word-that-contains-a-dash#
\def\hyph{-\penalty0\hskip0pt\relax}

\usepackage{rotating}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\setcounter{page}{2}
\renewcommand \contentsname {\centerline{\bfseries\large{\MakeUppercase{Зміст}}}}

% Зачем: Не захламлять основной файл
% Примечание: \small\selectfont злостный хак, чтобы уменьшить размер шрифта в ToC 
{

\normalsize\selectfont
\tableofcontents
\newpage
}

\setlength{\parindent}{1.25cm}
\sectioncentered*{Вступ}
\addcontentsline{toc}{section}{Вступ}
\label{sec:intro}

\indent Орієнтовану мережу можна інтерпретувати як деяку транспортну мережу і використовувати її для вирішення задач про потоки речовин в системі трубопроводів. Уявімо, що деякий продукт передається по системі від джерела, де даний продукт виробляється, до стоку, де він споживається. 
Джерело виробляє продукт з деякою максимальною швидкістю, а стік з тією ж швидкістю споживає продукт. Потоком продукту в будь-якій точці системи є швидкість руху продукту.
За допомогою транспортних мереж можна моделювати течію рідин
по трубопроводах, рух деталей на складальних лініях, передачу струму по
електричним мережам, інформації - в інформаційних мереж і т. д. Кожне
орієнтоване ребро мережі можна розглядати як канал, по якому рухається продукт. Кожен канал має задану пропускну здатність, яка характеризує максимальну швидкість переміщення продукту по каналу.
Вершини є точками перетину каналів. Через вершини, відмінні від
джерела і стоку, продукт проходить не накопичуючись.

У задачі про максимальний потік ми хочемо знайти максимальну швидкість
пересилання продукту від джерела до стоку, при якій не будуть порушуватися
обмеження пропускної здатності. Ця проблема була поставлена Т.Є. Харрісом навесні 1955 року, який разом з відставним генералом Ф.С. Россом запропонував спрощену модель залізничного транспортного потоку і висунув саме цю спеціальну задачу як центральну, підказаною цією моделлю. Незабаром після цього був висловлений в якості гіпотези, а потім і встановлений головний результат - теорема «Про максимальний потік і мінімальний розріз».
\par{}У даній роботі розглядається узагальнений метод Форда-Фалкерсона для транспортної мережі з обмеженою пропускною здатністю дуг а також з ціною за транспортування одиниці продукту через мережу. В якості алгоритму побудови рішення був обраний алгоритм Баскера-Гоуєна.

\section{ Задача про максимальний потік }
\subsection{Постановка задачі}

\indent{\it Орієнтованої мережею } 
називається граф $G = [V, E]$, який складається із сукупності $V$ елементів $x, y, ...$ разом з множиною $E$ деяких впорядкованих пар $(x, y)$ елементів, взятих з $V$.

{\it Вузли} - елементи множини $V$.
	
{\it Дуги} - елементи множини $E$. Можливість дуги $(x,x)$ вилучається.

Поставимо кожній дузі $(x, y)$ у відповідність деяке число $c (x, y)$ ,яке називається пропускною здатністю дуги. Пропускна здатність показує яка кількість речовини може пройти по цій дузі в одиницю часу. 

Потоком (flow) в мережі є дійсна функція $f: VxV-> R$ задовольняє трьом умовам:
\begin{enumerate}
\item обмеження пропускної здатності $$\forall u,v \in V f(u,v)\leqslant c(u,v)$$
Потік з однієї вершини в іншу не повинен перевищувати задану пропускну здатність.
\item антисиметричність $$f(u,v)=-f(v,u) \forall u,v \in V$$
Потік з вершини $u$ в вершину $v$ протилежний потоку у зворотному напрямку.
\item збереження потоку $$\forall u \in V/s,t \sum_{v\in V} f(u,v)=0$$
\end{enumerate}
Сумарний потік, що виходить з вершини, що не є джерелом або стоком дорівнює нулю. Величина потоку визначається як сумарний потік, що виходить з джерела.
$$|f|=\sum_{v\in V}f(s,v)$$
Будемо називати $s$ {\it джерелом} $t$ {\it стоком}, а інші вузли - проміжними.

Задача про максимальний потік (maximum flow poblem) полягає в знаходженні потоку максимальної величини. Математично постановка виглядає так:
$$
\begin{aligned}
&max\quad  v=f(s,V)& \\
&f(x,V)-f(V,X)=0, &x\neq s,t, \\
&0\leqslant f(x,y) \leqslant c(x,y) , &(x,y)\in E,
\end{aligned} 
$$

\subsection{Метод Форда-Фалкерсона}
Метод Форда-Фалкерсона базується на трьох важливих концепціях. Це залишкові мережі, що збільшують шляхи і розрізи. 
Метод є ітеративним. Спочатку значення потоку  встановлюється нуль. $f(u,v)=0  \forall u,v \in V$ На кожній ітерації величина потоку збільшується 
за допомогою пошуку збільшуючого шляху (деякого шляху від джерела до стоку вздовж якого можна відправити більший потік) і подальшого збільшення потоку. 
Цей процес повторюється до тих пір, поки вже неможливо відшукати збільшуваного шлях.

\indent Залишкові мережі

\indent Нехай задана транспортна мережа $G(V,E)$ з джерелом $s$ і стоком $t$. Нехай $f$ деякий потік в $G$.
Розглянемо пару вершин $u,v \in V$. Величина додаткового потоку, який ми можемо 
направити з $u$ в $v$, щоб не перевищити пропускну здатність $c(u,v)$ є залишковою 
пропускною здатністю ребра $(u,v)$ і задається формулою:
$$c_{f}(u,v)=c(u,v)-f(u,v)$$

Для транспортної $G(V,E)$ мережі і потоку $f$ залишковою мережею в $G$, породженою потоком $f$ є мережа 
$G_{f}=(V,E_{f})$  где $$E_{f}=(u,v)\in VxV:c_{f}(u,v)>0$$
Таким чином по кожному ребру залишкової мережі або залишковому ребру можна направити потік більше нуля.

\indent Збільшуючі шляхи

\indent Для заданої транспортної мережі $G=(V,E)$ і потоку $f$ збільшуючим шляхом $p$ є простий шлях з $s$ в $t$ в залишковій мережі $G_{f}$.
Максимальна величина, на яку можна збільшити потік уздовж кожного ребра $p$ збільшуючого шляху називається пропускною здатністю шляху і задається формулою:
$$c_{f}(p)=min\{c(u,v):(u,v)\in p\}$$.

\indent Розрізи транспортних мереж

\indent Розрізом транспортної мережі $G(V,E)$ називається розбиття множини вершин на множини $S$ та $T$ такі що $s\in S, t\in T$.
Якщо $f$ потік - то чистий потік через розріз $(S,T)$ визначимо як $f(S,T)$.
Пропускну здатність розрізу $(S,T)$ визначимо відповідно $c(S,T)$.
Мінімальним розрізом є розріз, пропускна здатність якого серед всіх розрізів мінімальна. Як видно, 
потік через розріз, на відміну від пропускної здатності розрізу, може включати і від’ємні доданки.
\newtheorem{theorem}{Теорема}
\begin{theorem}[ Про максимальний потік і мінімальний розріз]
Для будь-якої мережі максимальна величина потоку з $s$ в $t$ 
дорівнює мінімальній пропускній здатності розрізу, що відокремлює $s$ и $t$.  \cite{ford}
\end{theorem}

\subsection{Алгоритм Баскера-Гоуєна}

%\indent Алгоритм Едмондса-Карпа це варіант алгоритму Форда-Фалкерсона, при якому на кожному кроці обирають найкоротший шлях 
%з $s$ в $t$ залишкової мережі (вважаючи, що кожне ребро має одиничну довжину). Найкоротший шлях знаходиться пошуком в ширину.
%
%\section{ Потоки мінімальної вартості}
%%\subsection{Постановка задачі}
%\paragraph{} Розглянемо завдання про пошук потоку заданоъ велечини мінімальної вартості для випадку, коли кожне ребро мережі має ціну за транспортування одиниці товару.
%Припустимо, що кожне ребро $x$ має ціну за транспортування одиниці потоку $ c_{ij}$ і що потрібно знайти максимальний потік з $ s $ в $ t $ який не перевищує заданої потужності.
%\par Точніше припустимо, що всі джерельні дуги спрямовані з джерела, а всі стокові - в стік і що потрібно знайти такий потік при якому  $ f (s, N)=v $, причому виконуються умови:
%\begin{eqnarray}
%f(x,N)-f(N,X)&=0, &x\neq s,t, \\
% 0\leqslant f(x,y) &\leqslant c(x,y) , &(x,y)\in A,\\
%f(N,t) &\leqslant k(t) .&
% \end{eqnarray}
%Та треба мінімізувати функцію:
%$$z=\sum_{i,j}c_{ij}x_{ij}$$
%\subsection{Метод розв’язування}
%
%Для розв'язування задачі будемо використовувати алгоритм Баскера-Гоуєна:
%\begin{enumerate}
%\item Знайдемо поток мінімальної вартості із $ s $ в $ t $.
%\item З'ясуемо максимальну величину потоку яку можна пропустити через цей ланцюг.
%\item Якщо ця велечина більша за потрібну потужність мережі візмемо її рівною потрібній потужності.
%\item 	Збільшити поток по цьому ланцюгу на максимальну величину(але так щоб загальний  поток через мережу не перевищував потрібний)
%\item 	Розрахувати ціну за транспортування потужності. Додати до загальної ціни потоку.
%\item 	Якщо поток по мережі дорівнюе заданому то припинити роботу алгоритму. Інакше перейти на крок $а$
%\end{enumerate}
% Цю задачу можна звести до випадку пропускних здатностей дуг.
%Побудуємо для мережі $[N;A]$ наступним чином нову мережу $[N^*;A^*]$ .
%Кожному вузлу $x\in N$ поставимо у відповідність два вузла $x^{'} , x^{''} \in N^*$; якщо  $(x,y)\in A$ то $(x^{'},y^{''})\in A^*$ та, окрім того, $(x^{''},x^{'})\in a^{*}$ для кожного вузла $x\in N$. Функція пропускної здатності (дуг) визначається на $a^{*}$ формулами:
%\begin{eqnarray}
%c^{*}(x^{'},y^{''})&=c(x,y)  , &(x,y)\in A, \\
%c^{*}(x^{''},x^{'})&=k(x) , &x\in N. 
%\end{eqnarray}
%\par Наприклад для мережі $[N,A]$ зображеної на малюнку [1] відповідає мережа $[N^{*},A^{*}]$
%зображена на малюнку [2]. В результаті кожен вузол $x$ розбивається на дві частини: "ліву" частину $x^{''}$ і "праву" частину $x^{'}$, так що всі
%\begin{figure}[h]
%\begin{center}
%\includegraphics[scale=1]{11_1.jpg}
%\caption{Початкова мережа }
%\end{center}
%\end{figure}
%\begin{figure}[h]
%\begin{center}
%\includegraphics[scale=1]{11_2.jpg}
%\caption{ Відповідна їй мережа }
%\end{center}
%\end{figure}
%дуги, що входили у вузол $x$, тепер входять в його ліву частину, а всі дуги виходили з $x$, тепер виходять в його правій частині. 
%Пропускна здатність $k(x)$ вузла $x$ приписується в якості пропускної здатності нової дуги, що веде з лівої частини вузла $x$ в його праву частину. \\
%\par Таким чином, якщо покласти
%\begin{eqnarray} 
%f^{*}(x^{'},y^{''})&=f(x,y),&(x,y)\in A, \\
%f^{*}(x^{''},x^{'})&=f(x,N), &x\neq t,\\
%f^{*}(t^{''},t^{'})&=f(N,t),&
%\end{eqnarray} \\
%то будь-яка функція f, яка задовольняє умовам (2) - (5), тобто будь-який потік з $s$ в $t$ в мережі $[V, E]$, що не перевищує пропускних здатностей вузлів, дає еквівалентний потік $f^{*}$ з $s^{''}$ в $t^{'}$ в мережі $[N^{*},A^{*}]$, и навпаки.
%
%Якщо розширити поняття розрізу, включивши в такі множини не тільки дуги а й вузли, то аналог теореми про максимальний потік і мінімальному розрізі стверджує, що максимальна величина потоку дорівнює пропускній здатності розрізної множини вузлів і дуг, що має мінімальну пропускну здатність.









\section{Приклади}
Задача 1

\indent У деякої компанії "Аврора" є фабрика в Берліні, що виробляє стільці, а в Бремені склад, де вони зберігаються. Компанія орендує місце на вантажівках інших фірм для доставки стільців з фабрики на склад. Оскільки вантажівки їздять по певних маршрутах між містами і мають обмежену вантажопідйомність, компанія може перевозити не більше певної кількості ящиків на день між містами. Також, через трафік в містах за день по місту може проїхати тільки певна кількість машин. Компанія не може вплинути на маршрути і пропускну здатність. Її завдання визначити, яку найбільшу кількість ящиків за один день можна відвантажувати, а потім виробляти саме таку кількість, оскільки не має сенсу виробляти більше стільців, чим можна відправити на склад.

\indent Фабрику будемо вважати джерелом $(s)$, склад - стоком $(t)$. \\
Маршрути між містами будемо вважати ребрами мережі.\\
Вантажопідйомність вантажівок будемо вважати обмеженням пропускної спроможності на ребрах $c(u,v)$.
Трафік в містах будемо вважати обмеженням пропускної здатності в вершинах $k(v)$.
Занесемо дані в таблицю, де кожен елемент - обмеження пропускної здатності між відповідними містами (нуль означає що маршрут відсутній):
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.65]{p1.jpg}
\caption{Транспортна мережа}
\end{center}
\end{figure}
\\
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
0&10&15&0&0 \\
\hline
0&0&20&25&0 \\
\hline
0&0&0&0&30 \\
\hline
0&0&0&0&20 \\
\hline
0&0&0&0&0 \\
\hline
\end{tabular}
\end{center}
обмеження пропускних здатності у містах задано наступним вектором:
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
100&20&30&40&100 \\
\hline
\end{tabular}
\end{center}

\indent В результаті роботи програми було отримано наступне рішення:
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
0&10&15&0&0 \\
\hline
0&0&10&0&0 \\
\hline
0&0&0&0&25 \\
\hline
0&0&0&0&0\\
\hline
0&0&0&0&0 \\
\hline
\end{tabular} \\
Максимальний потік в мережі - {\bf 25} одиниць продукції.
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Задача 2

\indent
У пік туристичного сезону часто складно доїхати з Києва до Одеси, через те що залізниця не може перевезти всіх бажаючих, тому що вона може запустити тільки певне число поїздів по маршруту. Керівництво залізниці хоче з'ясувати, який максимальний потік пасажирів можливо перевезти з Одеси в Київ, і порівняти з очікуваним потоком пасажирів, який відомий на основі статистичних даних за попередні роки.
Кожен маршрут між станціями може пропускати тільки певна кількість вагонів у день.
Також кожна станція може обробляти тільки певну кількість вагонів у день (приєднувати і перевіряти).
Керівництво знає, що для задоволення потреб необхідно щоб щодня до Одеси можна було перевезти 250 чоловік.

\indent
Зведемо дану задачу до задачі про максимальний потік.
\par Будемо вважати Київ джерелом $s$ а Одесу стоком $t$. Колії між станціями будемо вважати ребрами мережі, з обмеженнями на пропускну здатність $c(x,y)$ заданої в вигляді таблиці.
\par Станції будемо вважати вузлами транспортної мережі з обмеженнями на вузлах $k(x)$ заданими в векторній формі.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.65]{p2.jpg}
\caption{Транспортна мережа}
\end{center}
\end{figure}
\\
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
0&100&70&180&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&120&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&70&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&130&60&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&90&100&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&70&70&0&0 \\ \hline
0&0&0&0&0&0&0&0&70&30&0&0 \\ \hline
0&0&0&0&0&0&0&0&100&0&120&90 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&110 \\ \hline
0&0&0&0&0&0&0&0&60&0&150&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&100 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0 \\ \hline
\end{tabular}
\end{center}
обмеження пропускних здатності на станціях задано наступним вектором:
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
900&100&100&100&100&100&150&100&300&120&250&900 \\
\hline
\end{tabular}
\end{center}

\indent В результаті роботи програми було отримано наступне рішення:
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
0&0&0&0&0&0&0&0&0&0&0&0 \\ 
\hline
100&0&0&0&0&0&0&0&0&0&0&0 \\ 
\hline
70&0&0&0&0&0&0&0&0&0&0&0 \\ 
\hline
90&0&0&0&0&0&0&0&0&0&0&0 \\ 
\hline
0&100&0&0&0&0&0&0&0&0&0&0 \\ 
\hline
0&0&70&30&0&0&0&0&0&0&0&0 \\ 
\hline
0&0&0&60&0&0&0&0&0&0&0&0 \\ 
\hline
0&0&0&0&90&0&0&0&0&0&0&0 \\ 
\hline
0&0&0&0&10&70&30&0&0&0&0&0 \\ 
\hline
0&0&0&0&0&30&30&0&0&0&0&0 \\ 
\hline
0&0&0&0&0&0&0&0&0&60&0&0 \\ 
\hline
0&0&0&0&0&0&0&90&110&0&60&0 \\ 
\hline
\end{tabular}
\end{center}
Максимальний потік 260 пасажирів на день.
Цього вистачає для задоволення попиту.
%%%%%%%%%%%%%%%%%%%

Задача 3

\indent
У старому центрі одного з міст рух машин влаштовано так, що великій кількості машин, що їде ввечері в спальний район в будь-якому випадку доводиться проїжджати через кільцеве перехрестя, із за чого створюються затори. ДАІ спільно з комунальними підприємствами вирішило, що місто потребує побудови нової дороги, яка б розвантажила це перехрестя. Але їм необхідно знати, скільки смуг необхідно новій дорозі. Для цього необхідно дізнатися, скільки машин обиратимуть нову дорогу замість старої. Кожна дорога має обмежену пропускну спроможність. Кожне перехрестя також має обмежену пропускну спроможність.

\indent
Зведемо дану задачу до задачі про максимальний потік.
\par Будемо вважати центр міста - джерелом $s$ а спальний район стоком $t$. Шляхи між перехрестями будемо вважати ребрами мережі, з обмеженнями на пропускну здатність $c(x,y)$ заданої в вигляді таблиці.
\par Перехрестя будемо вважати вузлами транспортної мережі з обмеженнями на вузлах $k(x)$ заданими в векторній формі.
\par Для вирішення завдання знайдемо спочатку максимальний потік вихідної мережі. Потім додамо нове ребро, яке буде відображати дорогу, яку збираються будувати. Задамо цьому ребру нескінченну пропускну здатність. Знайдемо новий максимальний потік. Різниця між цими двома величинами і буде шуканим числом машин, які користуватимуться новою дорогою.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{p3.jpg}
\caption{Транспортна мережа}
\end{center}
\end{figure}
\\
\begin{center}
\begin{turn}{270}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
0&10000&10000&10000&0&0&0&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&100&70&80&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&40&60&0&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&200&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&120&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&200&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&220&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&150&150&100&70&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&120&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&150&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&150&150&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&100&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&120&10000 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&10000 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&10000 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0 \\
\hline
\end{tabular}
\end{turn}
\end{center}
обмеження пропускних здібностей на перехрестях задано наступним вектором:
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
10000&100&150&250&120&140&160&400&70&110&200&20&120&120&120&10000 \\
\hline
\end{tabular}
\end{center}
\indent В результаті роботи програми було отримано наступне рішення:
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
0&100&80&120&0&0&0&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&100&0&0&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&20&60&0&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&120&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&120&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&60&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&120&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&70&110&100&20&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&70&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&110&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&10&90&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&20&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&70 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&120 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&110 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0 \\
\hline
\end{tabular}
\end{center}
Максимальний потік 300 машин.\\
{\bf Тепер введемо нове ребро }, яке буде відповідати новій дорозі, що йде в об'їзд перехрестя
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{p3n.jpg}
\caption{Транспортна мережа}
\end{center}
\end{figure}
\\
\begin{center}
\begin{turn}{270}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
0&10000&10000&10000&0&0&0&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&100&70&80&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&40&60&0&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&200&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&120&0&0&0&0&{\bf1000}&0&0&0 \\ \hline
0&0&0&0&0&0&0&200&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&220&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&150&150&100&70&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&120&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&150&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&150&150&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&100&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&120&10000 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&10000 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&10000 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0 \\
\hline
\end{tabular}
\end{turn}
\end{center}
Потім подивимося на скільки збільшиться потік при додаванні нового ребра, що б встановити скільки смуг повинно бути у нової дороги.
Результуюче рішення:
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
0&100&90&160&0&0&0&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&90&10&0&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&30&60&0&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&160&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&120&0&0&0 \\ \hline
0&0&0&0&0&0&0&70&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&160&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&110&100&20&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&110&0&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&10&90&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&20&0 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&120 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&120 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&110 \\ \hline
0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0 \\
\hline
\end{tabular}
\end{center}
Ми бачимо, що в результаті максимальний потік машин збільшиться на 50 одиниць. Значить достатньо буде побудувати дорогу з однією смугою в кожну напрямку.
%%%%%%%%%%%%%%%%%%%%%%%%%

Задача 4

\indent
Зерно з трьох зерносховищ доставляється на вантажівках чотирьом птахівничим фермам, при цьому деякі зерносховища не можуть безпосередньо поставляти зерно певним фермам. Пропускна здатність маршрутів від зерносховищ до птахівничих ферм обмежена кількістю використовуваних вантажівок і числом виконуваних щодня рейсів. Також дозволені перевезення зерна з першого в друге сховище, а з другого в трете, об'ємом до 50-ти тонн. Необхідно встановити, чи буде задоволено попит ферм.

\indent
Зведемо дану задачу до задачі про максимальний потік.
\par Додамо фіктивне джерело $s$ і фіктивний стік $t$. З'єднаємо джерело з усіма зерносховищами, пропускну здатність цих дуг покладемо нескінченно великою (в рамках конкретного завдання), наприклад 1000.Всі ферми з'єднаємо зі стоком дугами, також з нескінченною пропускною здатністю. Пропускні здатність інших маршрутів $c(x,y)$задамо в вигляді таблиці.
\par Сховища і ферми будемо вважати вузлами транспортної мережі з обмеженнями на вузлах $k(x)$ заданими в векторній формі.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.65]{p4.jpg}
\caption{Транспортна мережа}
\end{center}
\end{figure}
\\
\begin{center}
\begin{tabular}{|c|c|c|c||c|c|c|c|c|}
\hline
0&1000&1000&1000&0&0&0&0&0 \\ \hline
0&0&50&0&40&10&0&80&0 \\ \hline
0&0&0&50&0&0&15&90&0 \\ \hline
0&0&0&0&100&50&30&40&0 \\ \hline \hline
0&0&0&0&0&0&0&0&1000 \\ \hline
0&0&0&0&0&0&0&0&1000 \\ \hline
0&0&0&0&0&0&0&0&1000 \\ \hline
0&0&0&0&0&0&0&0&1000 \\ \hline
0&0&0&0&0&0&0&0&0 \\ \hline
\end{tabular}
\end{center}
обмеження пропускної здатності на станціях задано наступним вектором:
\begin{center}
\begin{tabular}{|c|c|c|c||c|c|c|c|c|}
\hline
1000&40&80&180&180&10&60&30&1000  \\
\hline
\end{tabular}
\end{center}

\indent В результаті роботи програми було отримано наступне рішення:
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
0&40&45&140&0&0&0&0&0 \\ \hline
0&0&0&0&40&0&0&0&0 \\ \hline
0&0&0&0&0&0&15&30&0 \\ \hline
0&0&0&0&100&10&30&0&0 \\ \hline
0&0&0&0&0&0&0&0&140 \\ \hline
0&0&0&0&0&0&0&0&10 \\ \hline
0&0&0&0&0&0&0&0&45 \\ \hline
0&0&0&0&0&0&0&0&30 \\ \hline
0&0&0&0&0&0&0&0&0 \\ \hline
\end{tabular}
\end{center}
Максимальний потік 225 тонн на день. 
Цього не вистачає для задоволення попиту. 
З рішення видно, що перша ферма отримує 140 тонн при попиті в 180, а третя 45, при попиті 60. 
У інших двох ферм попит буде задоволений.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Висновки}
У даній роботі було розглянуто узагальнення задачі про максимальний потік для транспортної мережі з ціною на транспортування одиниці товару церез ребро. Як алгоритм рішення був обрний алгоритм Баскера-Гоуєна.Булa розроблена програма на мові с\# що реалізує даний метод.Робота програми була протестовна на декількох прикладних зaдачaх.

\newpage
\renewcommand{\bibsection}{\sectioncentered*{Cписок використанної літератури}}
\addcontentsline{toc}{section}{Cписок використанної літератури}

\begin{thebibliography}{99}
\bibitem{ford} Форд, Л.Р. Потоки в сетях. /Л.Р. Форд, Д.Р. Фалкерсон - Москва : Мир, 1966. - 273 с.
\bibitem{taxa} Таха Хемди А. ВВедение в исследование операций /А. Таха - Москва : Вильямс, 2006. - 912 с.
\bibitem{vagner}Вагнер Г. Основы исследования операций. Том 1./Г. Вагнер - Москва : Мир, 1973. - 336 с.
\bibitem{kormen}Кормен Томас Х. Алгоритмы: построение и анализ./К.Х. Томас, Ч.Л. Лейзерсон, Р.Д. Риверс, К. Штайн - Москва : Вільямс, 2005. - 1296 с.
\bibitem{xyt} Ху Т. Целочислнное програмированние и потоки в сетях/Т. Ху - Москва : Мир, 1974. - 513 с.
\bibitem{met} Арсирий А.В. Сетевые модели./ А.В.Арсирій, Б.Ф.Трофимов, Є.М. Страхов - Одеса : Одеський національний університет імені І.І.Мечникова, 2011. - 42 с.
\end{thebibliography}
%
%\sectioncentered*{Додаток A}
%\addcontentsline{toc}{section}{Додаток A}
%\label{sec:A}
%
%\begin{figure}[h]
%\begin{center}
%\includegraphics[scale=0.7]{inter.jpg}
%\caption{Інтерфейс програми}
%\end{center}
%\end{figure}
%
%\begin{figure}[h]
%\begin{center}
%\includegraphics[scale=0.75]{vvod.jpg}
%\caption{Приклад використання програми}
%\end{center}
%\end{figure}
%
\sectioncentered*{Додаток A}
\addcontentsline{toc}{section}{Додаток A}
\label{sec:A}

\begin{lstlisting}[style=csharpinlinestyle]
 private static FlowCost CalculateFlow(int[,] flows, int[,] costs, int s, int t, int neededFlow)
        {
            var totalFlow = 0;
            var totalCost = 0;
            if (s == t)
                throw new ArgumentException("input and output should be different points");
            MilestoneHist[] path = bfs(flows, costs, s, t);
            while (path[t] != null)
            {
                int maxFlow = getMaxFlowForPath(flows, path, s, t);
                if (neededFlow - totalFlow < maxFlow)
                {
                    maxFlow = neededFlow - totalFlow;
                    flows = updateFlows(maxFlow, flows, path, s, t);
                    totalCost += maxFlow * path[t].totalCost;
                    path = bfs(flows, costs, s, t);
                    totalFlow += maxFlow;
                    return new FlowCost { totalCost = totalCost, resultingFlows = flows };
                }
                flows = updateFlows(maxFlow, flows, path, s, t);
                totalCost += maxFlow * path[t].totalCost;
                path = bfs(flows, costs, s, t);
                totalFlow += maxFlow;
            }
            return new FlowCost { totalCost = totalCost, resultingFlows = flows };
        }

public static MilestoneHist[] bfs(int[,] rGraph, int[,] costGraph, int s, int t)
        {
            var debug = 0;
            int Size = rGraph.GetLength(0);
            MilestoneHist[] parent = new MilestoneHist[Size];
            parent[s] = new MilestoneHist { totalCost = 0, pointNum = -1 };
            bool[] visited = new bool[Size];

            Queue q = new Queue();
            q.Enqueue(s);

            while (q.Count != 0)
            {
                int u = (int)q.Dequeue();
                debug++;
                if (debug > 10000)
                    throw new StackOverflowException();

                for (int v = 0; v < Size; v++)
                {
                    if (v != s && rGraph[u, v] > 0)
                    {
                        if (parent[v] == null)
                        {
                            parent[v] = new MilestoneHist { pointNum = u, totalCost = parent[u].totalCost + costGraph[u, v] };
                            q.Enqueue(v);
                        }
                        else
                        {
                            int newCost = parent[u].totalCost + costGraph[u, v];
                            int oldCost = parent[v].totalCost;
                            if (newCost < oldCost)
                            {
                                parent[v] = new MilestoneHist { pointNum = u, totalCost = newCost };
                                q.Enqueue(v);
                            }
                        }
                    }
                }
            }
            return parent;
        }
\end{lstlisting}


\end{document}
